{"ast":null,"code":"import * as l from 'react';\nimport { forwardRef, useRef, useState, useEffect, useImperativeHandle } from 'react';\nvar G = () => {};\nfunction Y(e, t, m) {\n  let a = useRef(G);\n  useEffect(() => {\n    a.current = e;\n  }), useEffect(() => {}, [m]), useEffect(() => {\n    if (t === null || t === !1) return;\n    let b = setInterval(() => a.current(), t);\n    return () => clearInterval(b);\n  }, [t]);\n}\nfunction k(e, t) {\n  return Math.random() * (t - e + 1) + e;\n}\nfunction h(e, t) {\n  return Math.floor(k(e, t));\n}\nvar Q = forwardRef((_ref, C) => {\n    let {\n      progress: e,\n      height: t = 2,\n      className: m = \"\",\n      color: a = \"red\",\n      background: d = \"transparent\",\n      onLoaderFinished: b,\n      transitionTime: n = 300,\n      loaderSpeed: i = 500,\n      waitingTime: N = 1e3,\n      shadow: y = !0,\n      containerStyle: T = {},\n      style: E = {},\n      shadowStyle: O = {},\n      containerClassName: z = \"\"\n    } = _ref;\n    let S = useRef(!1),\n      [p, c] = useState(0),\n      f = useRef({\n        active: !1,\n        refreshRate: 1e3\n      }),\n      [R, I] = useState({\n        active: !1,\n        value: 60\n      }),\n      F = {\n        height: \"100%\",\n        background: a,\n        transition: `all ${i}ms ease`,\n        width: \"0%\"\n      },\n      H = {\n        position: \"fixed\",\n        top: 0,\n        left: 0,\n        height: t,\n        background: d,\n        zIndex: 99999999999,\n        width: \"100%\"\n      },\n      j = {\n        boxShadow: `0 0 10px ${a}, 0 0 10px ${a}`,\n        width: \"5%\",\n        opacity: 1,\n        position: \"absolute\",\n        height: \"100%\",\n        transition: `all ${i}ms ease`,\n        transform: \"rotate(2deg) translate(0px, -2px)\",\n        left: \"-10rem\"\n      },\n      [g, P] = useState(F),\n      [w, L] = useState(j);\n    useEffect(() => (S.current = !0, () => {\n      S.current = !1;\n    }), []), useImperativeHandle(C, () => ({\n      continuousStart(r) {\n        let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e3;\n        if (R.active) return;\n        if (e !== void 0) {\n          console.warn(\"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\");\n          return;\n        }\n        let s = r || h(10, 20);\n        f.current = {\n          active: !0,\n          refreshRate: o\n        }, c(s), u(s);\n      },\n      staticStart(r) {\n        if (f.current.active) return;\n        if (e !== void 0) {\n          console.warn(\"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\");\n          return;\n        }\n        let o = r || h(30, 60);\n        I({\n          active: !0,\n          value: o\n        }), c(o), u(o);\n      },\n      start() {\n        let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"continuous\";\n        let o = arguments.length > 1 ? arguments[1] : undefined;\n        let s = arguments.length > 2 ? arguments[2] : undefined;\n        if (e !== void 0) {\n          console.warn(\"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\");\n          return;\n        }\n        r === \"continuous\" ? f.current = {\n          active: !0,\n          refreshRate: s || 1e3\n        } : I({\n          active: !0,\n          value: o || 20\n        });\n        let q = h(10, 20),\n          A = h(30, 70),\n          V = o || (r === \"continuous\" ? q : A);\n        c(V), u(V);\n      },\n      complete() {\n        if (e !== void 0) {\n          console.warn(\"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\");\n          return;\n        }\n        c(100), u(100);\n      },\n      increase(r) {\n        if (e !== void 0) {\n          console.warn(\"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\");\n          return;\n        }\n        c(o => {\n          let s = o + r;\n          return u(s), s;\n        });\n      },\n      decrease(r) {\n        if (e !== void 0) {\n          console.warn(\"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\");\n          return;\n        }\n        c(o => {\n          let s = o - r;\n          return u(s), s;\n        });\n      },\n      getProgress() {\n        return p;\n      }\n    })), useEffect(() => {\n      P({\n        ...g,\n        background: a\n      }), L({\n        ...w,\n        boxShadow: `0 0 10px ${a}, 0 0 5px ${a}`\n      });\n    }, [a]), useEffect(() => {\n      if (C) {\n        if (C && e !== void 0) {\n          console.warn(`react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar! Please use only props or only ref methods! Ref methods will override props if \"ref\" property is available.`);\n          return;\n        }\n        u(p);\n      } else e && u(e);\n    }, [e]);\n    let u = r => {\n      r >= 100 ? (P({\n        ...g,\n        width: \"100%\"\n      }), y && L({\n        ...w,\n        left: r - 10 + \"%\"\n      }), setTimeout(() => {\n        S.current && (P({\n          ...g,\n          opacity: 0,\n          width: \"100%\",\n          transition: `all ${n}ms ease-out`,\n          color: a\n        }), setTimeout(() => {\n          S.current && (f.current.active && (f.current = {\n            ...f.current,\n            active: !1\n          }, c(0), u(0)), R.active && (I({\n            ...R,\n            active: !1\n          }), c(0), u(0)), b && b(), c(0), u(0));\n        }, n));\n      }, N)) : (P(o => ({\n        ...o,\n        width: r + \"%\",\n        opacity: 1,\n        transition: r > 0 ? `all ${i}ms ease` : \"\"\n      })), y && L({\n        ...w,\n        left: r - 5.5 + \"%\",\n        transition: r > 0 ? `all ${i}ms ease` : \"\"\n      }));\n    };\n    return Y(() => {\n      let r = Math.min(10, (100 - p) / 5),\n        o = Math.min(20, (100 - p) / 3),\n        s = k(r, o);\n      p + s < 95 && (c(p + s), u(p + s));\n    }, f.current.active ? f.current.refreshRate : null), l.createElement(\"div\", {\n      className: z,\n      style: {\n        ...H,\n        ...T\n      }\n    }, l.createElement(\"div\", {\n      className: m,\n      style: {\n        ...g,\n        ...E\n      }\n    }, y ? l.createElement(\"div\", {\n      style: {\n        ...w,\n        ...O\n      }\n    }) : null));\n  }),\n  M = l.createContext(void 0),\n  re = _ref2 => {\n    let {\n      children: e,\n      props: t\n    } = _ref2;\n    let [m, a] = useState(t || {}),\n      d = useRef(null),\n      b = function () {\n        let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"continuous\";\n        var i;\n        return (i = d.current) == null ? void 0 : i.start(n);\n      };\n    return l.createElement(M.Provider, {\n      value: {\n        start: b,\n        complete: () => {\n          var n;\n          return (n = d.current) == null ? void 0 : n.complete();\n        },\n        getProgress: () => {\n          var n;\n          return ((n = d.current) == null ? void 0 : n.getProgress()) || 0;\n        },\n        increase: n => {\n          var i;\n          return (i = d.current) == null ? void 0 : i.increase(n);\n        },\n        decrease: n => {\n          var i;\n          return (i = d.current) == null ? void 0 : i.decrease(n);\n        },\n        setProps: n => a({\n          ...n,\n          ...m\n        })\n      }\n    }, l.createElement(Q, {\n      ref: d,\n      ...m\n    }), e);\n  },\n  ne = e => {\n    let t = l.useContext(M);\n    if (!t) throw new Error(\"[react-top-loading-bar] useLoadingBar hook must be used within a LoadingBarContainer. Try wrapping parent component in <LoadingBarContainer>.\");\n    return useEffect(() => {\n      e && t.setProps(e);\n    }, []), {\n      start: t.start,\n      complete: t.complete,\n      increase: t.increase,\n      decrease: t.decrease,\n      getProgress: t.getProgress\n    };\n  };\nexport { re as LoadingBarContainer, Q as default, ne as useLoadingBar };\n//# sourceMappingURL=index.mjs.map","map":{"version":3,"names":["G","noop","Y","e","t","m","a","useRef","useEffect","current","b","setInterval","clearInterval","k","Math","random","h","floor","Q","forwardRef","_ref","C","progress","height","className","color","background","d","onLoaderFinished","transitionTime","n","loaderSpeed","i","waitingTime","N","shadow","y","containerStyle","T","style","E","shadowStyle","O","containerClassName","z","S","p","c","useState","f","active","refreshRate","R","I","value","F","transition","width","H","position","top","left","zIndex","j","boxShadow","opacity","transform","g","P","w","L","useImperativeHandle","continuousStart","r","o","arguments","length","undefined","console","warn","s","u","staticStart","start","q","A","V","complete","increase","decrease","getProgress","setTimeout","min","l","createElement","M","createContext","re","_ref2","children","props","Provider","setProps","ref","ne","useContext","Error","LoadingBarContainer","default","useLoadingBar"],"sources":["D:\\newsapp\\node_modules\\react-top-loading-bar\\src\\useInterval.ts","D:\\newsapp\\node_modules\\react-top-loading-bar\\src\\utils.ts","D:\\newsapp\\node_modules\\react-top-loading-bar\\src\\index.tsx"],"sourcesContent":["import { useEffect, useRef } from \"react\";\n\n/** keep typescript happy */\nconst noop = () => {};\n\nexport function useInterval(\n  callback: () => void,\n  delay: number | null | false,\n  immediate?: boolean,\n) {\n  const savedCallback = useRef(noop);\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  });\n\n  // Execute callback if immediate is set.\n  useEffect(() => {\n    if (!immediate) return;\n    if (delay === null || delay === false) return;\n    savedCallback.current();\n  }, [immediate]);\n\n  // Set up the interval.\n  useEffect(() => {\n    if (delay === null || delay === false) return undefined;\n    const tick = () => savedCallback.current();\n    const id = setInterval(tick, delay);\n    return () => clearInterval(id);\n  }, [delay]);\n}\n","export function randomValue(min: number, max: number): number {\n  return (Math.random() * (max - min + 1) + min)\n}\n\nexport function randomInt(min: number, max: number): number {\n  return Math.floor(randomValue(min, max))\n}\n","import * as React from \"react\";\nimport {\n  CSSProperties,\n  useEffect,\n  useState,\n  forwardRef,\n  useImperativeHandle,\n  useRef,\n} from \"react\";\nimport { useInterval } from \"./useInterval\";\nimport { randomInt, randomValue } from \"./utils\";\n\nexport interface IProps {\n  progress?: number;\n  color?: string;\n  shadow?: boolean;\n  background?: string;\n  height?: number;\n  onLoaderFinished?: () => void;\n  className?: string;\n  containerClassName?: string;\n  loaderSpeed?: number;\n  transitionTime?: number;\n  waitingTime?: number;\n  style?: CSSProperties;\n  containerStyle?: CSSProperties;\n  shadowStyle?: CSSProperties;\n}\n\nexport interface LoadingBarRef {\n  continuousStart: (startingValue?: number, refreshRate?: number) => void;\n  staticStart: (startingValue?: number) => void;\n  start: (\n    type?: \"continuous\" | \"static\",\n    startingValue?: number,\n    refreshRate?: number,\n  ) => void;\n  complete: () => void;\n  increase: (value: number) => void;\n  decrease: (value: number) => void;\n  getProgress: () => number;\n}\n\nconst LoadingBar = forwardRef<LoadingBarRef, IProps>(\n  (\n    {\n      progress,\n      height = 2,\n      className = \"\",\n      color = \"red\",\n      background = \"transparent\",\n      onLoaderFinished,\n      transitionTime = 300,\n      loaderSpeed = 500,\n      waitingTime = 1000,\n      shadow = true,\n      containerStyle = {},\n      style = {},\n      shadowStyle: shadowStyleProp = {},\n      containerClassName = \"\",\n    },\n    ref,\n  ) => {\n    const isMounted = useRef(false);\n    const [localProgress, localProgressSet] = useState<number>(0);\n\n    const pressedContinuous = useRef<{\n      active: boolean;\n      refreshRate: number;\n    }>({ active: false, refreshRate: 1000 });\n\n    const [pressedStaticStart, setStaticStartPressed] = useState<{\n      active: boolean;\n      value: number;\n    }>({ active: false, value: 60 });\n\n    const initialLoaderStyle: CSSProperties = {\n      height: \"100%\",\n      background: color,\n      transition: `all ${loaderSpeed}ms ease`,\n      width: \"0%\",\n    };\n\n    const loaderContainerStyle: CSSProperties = {\n      position: \"fixed\",\n      top: 0,\n      left: 0,\n      height,\n      background,\n      zIndex: 99999999999,\n      width: 100 + \"%\",\n    };\n\n    const initialShadowStyles: CSSProperties = {\n      boxShadow: `0 0 10px ${color}, 0 0 10px ${color}`,\n      width: \"5%\",\n      opacity: 1,\n      position: \"absolute\",\n      height: \"100%\",\n      transition: `all ${loaderSpeed}ms ease`,\n      transform: \"rotate(2deg) translate(0px, -2px)\",\n      left: \"-10rem\",\n    };\n\n    const [loaderStyle, loaderStyleSet] =\n      useState<CSSProperties>(initialLoaderStyle);\n    const [shadowStyle, shadowStyleSet] =\n      useState<CSSProperties>(initialShadowStyles);\n\n    useEffect(() => {\n      isMounted.current = true;\n      return () => {\n        isMounted.current = false;\n      };\n    }, []);\n\n    useImperativeHandle(ref, () => ({\n      continuousStart(startingValue?: number, refreshRate: number = 1000) {\n        if (pressedStaticStart.active) return;\n        if (progress !== undefined) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\",\n          );\n          return;\n        }\n\n        const val = startingValue || randomInt(10, 20);\n\n        pressedContinuous.current = {\n          active: true,\n          refreshRate,\n        };\n\n        localProgressSet(val);\n        checkIfFull(val);\n      },\n      staticStart(startingValue?: number) {\n        if (pressedContinuous.current.active) return;\n        if (progress !== undefined) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\",\n          );\n          return;\n        }\n\n        const val = startingValue || randomInt(30, 60);\n\n        setStaticStartPressed({\n          active: true,\n          value: val,\n        });\n        localProgressSet(val);\n        checkIfFull(val);\n      },\n      start(type = \"continuous\", startingValue?: number, refreshRate?: number) {\n        if (progress !== undefined) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\",\n          );\n          return;\n        }\n\n        if (type === \"continuous\") {\n          pressedContinuous.current = {\n            active: true,\n            refreshRate: refreshRate || 1000,\n          };\n        } else {\n          setStaticStartPressed({\n            active: true,\n            value: startingValue || 20,\n          });\n        }\n\n        const continuousRandom = randomInt(10, 20);\n        const staticRandom = randomInt(30, 70);\n\n        const val =\n          startingValue ||\n          (type === \"continuous\" ? continuousRandom : staticRandom);\n\n        localProgressSet(val);\n        checkIfFull(val);\n      },\n      complete() {\n        if (progress !== undefined) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\",\n          );\n          return;\n        }\n        localProgressSet(100);\n        checkIfFull(100);\n      },\n      increase(value: number) {\n        if (progress !== undefined) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\",\n          );\n          return;\n        }\n        localProgressSet((prev) => {\n          const newVal = prev + value;\n          checkIfFull(newVal);\n          return newVal;\n        });\n      },\n      decrease(value: number) {\n        if (progress !== undefined) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\",\n          );\n          return;\n        }\n        localProgressSet((prev) => {\n          const newVal = prev - value;\n          checkIfFull(newVal);\n          return newVal;\n        });\n      },\n      getProgress() {\n        return localProgress;\n      },\n    }));\n\n    useEffect(() => {\n      loaderStyleSet({\n        ...loaderStyle,\n        background: color,\n      });\n\n      shadowStyleSet({\n        ...shadowStyle,\n        boxShadow: `0 0 10px ${color}, 0 0 5px ${color}`,\n      });\n    }, [color]);\n\n    useEffect(() => {\n      if (ref) {\n        if (ref && progress !== undefined) {\n          console.warn(\n            'react-top-loading-bar: You can\\'t use both controlling by props and ref methods to control the bar! Please use only props or only ref methods! Ref methods will override props if \"ref\" property is available.',\n          );\n          return;\n        }\n        checkIfFull(localProgress);\n      } else {\n        if (progress) checkIfFull(progress);\n      }\n    }, [progress]);\n\n    const checkIfFull = (_progress: number) => {\n      if (_progress >= 100) {\n        // now it should wait a little\n        loaderStyleSet({\n          ...loaderStyle,\n          width: \"100%\",\n        });\n        if (shadow) {\n          shadowStyleSet({\n            ...shadowStyle,\n            left: _progress - 10 + \"%\",\n          });\n        }\n\n        setTimeout(() => {\n          if (!isMounted.current) {\n            return;\n          }\n          // now it can fade out\n          loaderStyleSet({\n            ...loaderStyle,\n            opacity: 0,\n            width: \"100%\",\n            transition: `all ${transitionTime}ms ease-out`,\n            color: color,\n          });\n\n          setTimeout(() => {\n            if (!isMounted.current) {\n              return;\n            }\n            // here we wait for it to fade\n            if (pressedContinuous.current.active) {\n              // if we have continuous loader just ending, we kill it and reset it\n\n              pressedContinuous.current = {\n                ...pressedContinuous.current,\n                active: false,\n              };\n\n              localProgressSet(0);\n              checkIfFull(0);\n            }\n\n            if (pressedStaticStart.active) {\n              setStaticStartPressed({\n                ...pressedStaticStart,\n                active: false,\n              });\n              localProgressSet(0);\n              checkIfFull(0);\n            }\n\n            if (onLoaderFinished) onLoaderFinished();\n            localProgressSet(0);\n            checkIfFull(0);\n          }, transitionTime);\n        }, waitingTime);\n      } else {\n        loaderStyleSet((_loaderStyle) => {\n          return {\n            ..._loaderStyle,\n            width: _progress + \"%\",\n            opacity: 1,\n            transition: _progress > 0 ? `all ${loaderSpeed}ms ease` : \"\",\n          };\n        });\n\n        if (shadow) {\n          shadowStyleSet({\n            ...shadowStyle,\n            left: _progress - 5.5 + \"%\",\n            transition: _progress > 0 ? `all ${loaderSpeed}ms ease` : \"\",\n          });\n        }\n      }\n    };\n\n    useInterval(\n      () => {\n        const minValue = Math.min(10, (100 - localProgress) / 5);\n        const maxValue = Math.min(20, (100 - localProgress) / 3);\n\n        const random = randomValue(minValue, maxValue);\n\n        if (localProgress + random < 95) {\n          localProgressSet(localProgress + random);\n          checkIfFull(localProgress + random);\n        }\n      },\n      pressedContinuous.current.active\n        ? pressedContinuous.current.refreshRate\n        : null,\n    );\n\n    return (\n      <div\n        className={containerClassName}\n        style={{ ...loaderContainerStyle, ...containerStyle }}\n      >\n        <div className={className} style={{ ...loaderStyle, ...style }}>\n          {shadow ? (\n            <div style={{ ...shadowStyle, ...shadowStyleProp }} />\n          ) : null}\n        </div>\n      </div>\n    );\n  },\n);\n\ninterface IContext\n  extends Omit<LoadingBarRef, \"continuousStart\" | \"staticStart\"> {\n  setProps: (props: IProps) => void;\n}\n\nconst LoaderContext = React.createContext<IContext>(undefined as any);\n\nexport const LoadingBarContainer = ({\n  children,\n  props,\n}: {\n  children: React.ReactNode;\n  props?: Omit<IProps, \"progress\">;\n}) => {\n  const [hookProps, setProps] = useState<IProps>(props || {});\n\n  const ref = useRef<LoadingBarRef>(null);\n\n  const start = (type: \"continuous\" | \"static\" = \"continuous\") =>\n    ref.current?.start(type);\n\n  return (\n    <LoaderContext.Provider\n      value={{\n        start,\n        complete: () => ref.current?.complete(),\n        getProgress: () => ref.current?.getProgress() || 0,\n        increase: (value: number) => ref.current?.increase(value),\n        decrease: (value: number) => ref.current?.decrease(value),\n        setProps: (props: IProps) => setProps({ ...props, ...hookProps }),\n      }}\n    >\n      <LoadingBar ref={ref} {...hookProps} />\n      {children}\n    </LoaderContext.Provider>\n  );\n};\n\nexport const useLoadingBar = (props?: IProps): Omit<IContext, \"setProps\"> => {\n  const context = React.useContext(LoaderContext);\n\n  if (!context) {\n    throw new Error(\n      \"[react-top-loading-bar] useLoadingBar hook must be used within a LoadingBarContainer. Try wrapping parent component in <LoadingBarContainer>.\",\n    );\n  }\n\n  useEffect(() => {\n    if (props) context.setProps(props);\n  }, []);\n\n  return {\n    start: context.start,\n    complete: context.complete,\n    increase: context.increase,\n    decrease: context.decrease,\n    getProgress: context.getProgress,\n  };\n};\n\nexport { LoadingBar as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}